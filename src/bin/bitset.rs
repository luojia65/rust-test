// Idea: 
// lowest -- index = 0
// highest -- index = n - 1

// use core::marker::PhantomData;

// pub struct BitSet<S = Vec<usize>> {
//     storage: S,
// }

// impl<T, U> AsRef<BitSet<U>> for BitSet<T>
// where T: AsRef<U> {
//     fn as_ref(&self) -> &T {
//         &BitSet { storage: self.storage.as_ref() }
//     }
// }
 
fn main () {}
