// use std::ops::RangeBounds;

// pub struct DenseVecMat<T> {
//     buf: Vec<T>,
//     shape: [usize; 2],
// }

// impl<T> DenseVecMat<T> {
//     pub fn new() -> Self {
//         DenseVecMat {
//             buf: Vec::new(),
//             shape: [0, 0],
//         }
//     }
// }

// impl<T, U: RangeBounds> Index<U> for DenseVecMat<T> {
//     type Output = MatView<'a, T>;
//     fn index([i]: [usize; 1]) -> &MatView<'a, T> {
        
//     }
// }

// pub struct MatView<'a, T, U, V> {
//     slice: &'a [T],
//     shape: [usize; 2],
//     transposed: bool,
//     bound_i: U,
//     bound_j: V,
// }
fn main () {}